---
title: "Post-Payment (After Successful Checkout)"
---

/This section explains **everything that happens after a payment is made**, starting from Stripe webhook to DB writes, emails, and user redirection.

## Core Logic Flow

After a payment is completed, Stripe sends a webhook to our system.\
The webhook determines the payment status and routes the event to the correct handler.\
For class purchases, all post-payment logic is handled by `updateClassPayment()`.

## `stripePaymentListener` (Stripe Webhook)

We have a single webhook (`stripePaymentListener`) that is triggered by Stripe events such as `payment_intent.succeeded`, `checkout.session.completed`, or async bank transfer updates . This API acts as the single entry point for all post-payment processing.

This webhook (1) validates the Stripe webhook signature and extracts the `payment_intent` with checkout metadata; (2) finds the related record from `stripe_checkout_customer` and normalizes the event into internal payment states (Complete, Processing, Failed); (3) Based on the payment state, triggers the next functions.

_Events are normalized based on event type and status:_

- _payment_intent with requires_payment_method → "Failed"_


- _charge events: paid == True → "Complete"; status == "pending" → "Processing"; status == "failed" → "Failed"_


- _checkout.session with payment_status == "paid" and amount_total == 0 → "Complete"_

_The unique key is sessionId (Stripe Checkout Session ID). For payment_intent and charge events, the code retrieves the payment_intent ID, calls stripe.checkout.Session.list(payment_intent=paymentIntent) to get the session, then extracts sessionId from the session object. For checkout.session events, sessionId is directly available as eventObj["id"]. All lookups use: db.stripe_checkout_customer.find_one({"sessionId": sessionId})._

<Note>
  TODO:

  1. **How is the event normalized into internal payment states? Unclear right now**
  2. **What is the unique key from Stripe used to find the related record in** `stripe_checkout_customer`?
</Note>

\
The webhook ensures idempotency so repeated webhooks do not create duplicates.

_Idempotency is ensured by using payment_intent as the unique identifier. Each update function (updateInvoiceResponses, updateSummerPayment, updateClassPayment, updateUpsellPaymentDetails, addPurchaseTopicDetails) first checks if a record exists using find_one({"payment_intent": chargeObj["payment_intent"]}). If found, it updates the existing record (status, receipt_url, etc.) instead of inserting a new one. If not found, it inserts a new record. This ensures that repeated webhooks with the same payment_intent update existing records rather than creating duplicates, making the webhook idempotent._

<Note>
  **\<TODO: Explain how you ensure idempotency\>.**
</Note>

### Behaviour by payment status

- **Complete**: When a payment is marked as **Complete**, full post-payment processing is triggered via `updateClassPayment()`.
- **Processing**: For **Processing** payments, the payment is stored as pending in the stripe_checkout_customer. **\<TODO: stored as pending where?\>**
- **Failed**: For **failed** payments, all partial or temporary records are cleaned up.\
  No enrollment, credits, or referrals are applied.

### `updateClassPayment()`

`updateClassPayment()` is the **core business orchestration layer** for class purchases.\
It executes **all database writes, enrollment logic, referral handling, coupons, waitlist cleanup, and automated emails** associated with a payment.

Determines whether the payment is new or already processed (idempotency), then handles logic based on payment status (Complete, Processing, Failed).\
Persists payment and checkout state and applies all side effects associated with a successful purchase.

All sections below execute under this function unless explicitly skipped due to failure or pending status.

## Database Writes & Updates

### A. `payment_details`

- On the **first successful payment** (based on `payment_intent`), **we insert:**  payment_intent, payment_intent, amount, studentId, classId, memberId, device, UTM metadata, and couponCode (if applied).
- On subsequent webhook calls (with the same `payment_intent`), we update the `status` and `receipt_url`.

### B. `stripe_checkout_customer`

On every webhook event, we update the `payment_intent` & `status` (Complete / Processing / Failed).

_The unique identifier for stripe_checkout_customer is sessionId (Stripe Checkout Session ID), not payment_intent. All lookups use db.stripe_checkout_customer.find_one({"sessionId": sessionId}), and all updates use db.stripe_checkout_customer.update_one({'sessionId': sessionId}, ...). The payment_intent is a field that gets updated on each webhook event (along with status), but sessionId is the primary key that uniquely identifies each checkout session record. This makes sense because a single checkout session can have multiple payment attempts or webhook events, so the sessionId remains constant while payment_intent and status can change over time._

<Note>
  TODO: I thought `payment_intent` was the unique identifier? If it's not, than what is the unique identifier for `stripe_checkout_customer`, that you get from Stripe?
</Note>

### C. Failure Handling

If payment fails, we delete the payment details and any upsell payments, and mark the checkout `status` as Failed in `stripe_checkout_customer`.

## Referral & Coupon Processing

**If a coupon is used**, Stripe passes it as **\<TODO: insert\>**. We search to see if the coupon exists in **\<TODO: insert referral collection\>**. If a match is found, we mark the referral as Purchased and update the purchase date.

For any purchase, we check to see if the family (identified via their `familyId`) has a coupon in **\<TODO: insert collection\>**. If it does not exist, we generate **\<TODO: how?\>** a new referral coupon, create it in Stripe **\<TODO: are there any restrictions applied to this coupon?\>**, and store it in `coupon_details`.

_If a coupon is used, Stripe passes it as a promotion code in the checkout session's discount breakdown. We retrieve it via getCouponCode(sessionId), which extracts the promotion code from total_details.breakdown.discounts. We search referral_details using {"guestId": str(parent["\_id"])}. If a match is found, we mark the referral as Purchased and update the purchase date._

_For any purchase, we check coupon_details using {"familyId": member['familyId']} to see if the family has a coupon. If it doesn't exist, we generate a new referral coupon by calling generate_coupon_name(member['firstName']) (or member['name'] for class payments), which creates a unique code by: (1) taking the member's first name, (2) removing non-alphanumeric characters and converting to uppercase, (3) generating an MD5 hash of the name + "100", taking the first 5 characters, and (4) combining them as {BASENAME}{5CHARHASH} (e.g., "JOHN12345"). We create it in Stripe using stripe.PromotionCode.create() with restrictions: minimum_amount of \$100 (10000 cents), minimum_amount_currency "usd", and first_time_transaction set to True. The promotion code is based on a base coupon ID stored in AWS Parameter Store (/prod/stripe/coupon/id). We then store it in coupon_details with the coupon_code, familyId, and createdOn timestamp._

<Note>
  TODO: I rewrote this part to add more detail. Please fill in the TODOs. We'll need to give more details about the referral section in a different page, but this should be sufficient for payment purposes.
</Note>

## Trial → Paid Conversion

If the parent previously attended a trial class, the corresponding `trial_class_details`  is updated to `Purchased`. The lookup is performed via **\<TODO: explain\>**.

_The lookup is a two-step process. First, the parent is found in the members collection using a regex pattern that matches stripeCheckout["parentEmail"] to handle single or comma-separated emails: pattern = re.compile(rf'(^|\\s\*,\\s\*){re.escape(stripeCheckout["parentEmail"])}(\\s\*,\\s\*|\$)', re.IGNORECASE) and then parentData = db.members.find_one({"email": { "\$regex": pattern } }). If a parent is found, the trial_class_details collection is queried using {"parentId": str(parentData["\_id"])} — the parent's MongoDB id converted to a string. If a trial class record exists, it is updated to {"status": "Purchased"} using the trial class record's id. This links the payment to the trial class via the parent's email and MongoDB \_id._

## Enrollment & Cleanup

- **Waitlist cleanup**: Searches for student in the `waitlist_details` via **\<TODO: what key is used to search\>**. If found, then they are removed from the waitlist via deletion. 

  _The waitlist cleanup uses a compound key: both classId and studentId from stripeCheckout. The deletion is performed via db.waitlist_details.delete_one({ "classId": stripeCheckout["classId"], "studentId": stripeCheckout["studentId"] }). This removes the waitlist entry for the specific student in the specific class when the payment is processed. The lookup requires both fields to uniquely identify the waitlist record to delete._
- **Upsell Programs** (if any): Inserted into `upsell_payment_details`
- **Topic Purchases** (if any): Inserted into topic payment collection

<Note>
  TODO: We'll likely need a seperate note to more thoroughly explain how upsells work. I'll figure out the right structure. 
</Note>

## BDC Credit

If BDC credits were applied by the user, their credit balance is updated. \<TODO: how do we know if BDC credits were used; how is search done and in what collection.\>

_BDC credits are detected by checking if stripeCheckout contains "discount_amount" and it's greater than 0: if "discount_amount" in stripeCheckout and stripeCheckout["discount_amount"] \> 0. The search is performed in the member_credit_amount collection using {"memberId": stripeCheckout["memberId"]} to find the member's credit record. If found, the credit balance is updated by subtracting the discount_amount from the current credit_balance (ensuring it doesn't go below 0), and a debit entry is added to the credit_history array with details including the amount, type "debit", description "applied during checkout", paymentId, year, and sessionId. The update is performed via db.member_credit_amount.update_one({"memberId": stripeCheckout["memberId"]}, ...)._

## Emails Triggered

### Automated Emails

- **Admin Notification:** Sent on successful payment. Includes order & enrollment details
- **User Emails:** Automatically triggered receipt via Stripe. Same as the receipt_url stored in `payment_details`.

---

---