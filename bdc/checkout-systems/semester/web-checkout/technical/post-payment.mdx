---
title: "Post-Payment (After Successful Checkout)"
---

This section explains **everything that happens after a payment is made**, starting from Stripe webhook to DB writes, emails, and user redirection.

## Core Logic Flow

After a payment is completed, Stripe sends a webhook to our system.\
The webhook determines the payment status and routes the event to the correct handler.\
For class purchases, all post-payment logic is handled by `updateClassPayment()`.

## `stripePaymentListener` (Stripe Webhook)

We have a single webhook (`stripePaymentListener`) that is triggered by Stripe events such as `payment_intent.succeeded`, `checkout.session.completed`, or async bank transfer updates . This API acts as the single entry point for all post-payment processing.

This webhook (1) validates the Stripe webhook signature and extracts the `payment_intent` with checkout metadata; (2) finds the related record from `stripe_checkout_customer` and normalizes the event into internal payment states (Complete, Processing, Failed); (3) Based on the payment state, triggers the next functions.

In this webhook, Stripe events are normalized into three internal states: **Complete**, **Processing**, and **Failed**. A `payment_intent` with `status = "requires_payment_method"` is treated as **Failed**. For `charge` events, `paid = true` maps to **Complete**, `status = "pending"` maps to **Processing** (used for bank transfers), and `status = "failed"` maps to **Failed**. Separately, a `checkout.session` that is `paid`, `complete`, and has `amount_total = 0` (free-coupon flow) is also mapped to **Complete**. Overall, the system infers payment state from a limited set of Stripe fields and largely relies on `charge` events to represent success and in-progress states.

The unique key is the **sessionId** (Stripe Checkout Session ID). From the webhook event, we obtain the **payment_intent** from the charge object. Using this **payment_intent**, we retrieve the corresponding **sessionId**, which allows us to identify the session created by the app user.

<Note>
  TODO:

  1. **How is the event normalized into internal payment states? Unclear right now. Updated desc above**
  2. **What is the unique key from Stripe used to find the related record in** `stripe_checkout_customer`?  **Updated desc above**
</Note>

\
The webhook ensures idempotency so repeated webhooks do not create duplicates.

Idempotency is ensured by using payment_intent as the unique identifier. Each update function (updateInvoiceResponses, updateSummerPayment, updateClassPayment, updateUpsellPaymentDetails, addPurchaseTopicDetails) first checks if a record exists using `find_one({"payment_intent": chargeObj["payment_intent"]})`. If found, it updates the existing record (status, receipt_url, etc.) instead of inserting a new one. If not found, it inserts a new record. This ensures that repeated webhooks with the same payment_intent update existing records rather than creating duplicates, making the webhook idempotent.

<Note>
  **TODO: Explain how you ensure idempotency. Updated desc above**
</Note>

### Behaviour by payment status

- **Complete**: When a payment is marked as **Complete**, full post-payment processing is triggered via `updateClassPayment()`.
- **Processing**: For **Processing** payments, the payment is stored as pending in the **stripe_checkout_customer**. **TODO: stored as pending where?**
- **Failed**: For **failed** payments, all partial or temporary records are cleaned up.\
  No enrollment, credits, or referrals are applied.

### `updateClassPayment()`

`updateClassPayment()` is the **core business orchestration layer** for class purchases.\
It executes **all database writes, enrollment logic, referral handling, coupons, waitlist cleanup, and automated emails** associated with a payment.

Determines whether the payment is new or already processed (idempotency), then handles logic based on payment status (Complete, Processing, Failed).\
Persists payment and checkout state and applies all side effects associated with a successful purchase.

All sections below execute under this function unless explicitly skipped due to failure or pending status.

## Database Writes & Updates

### A. `payment_details`

- On the **first successful payment** (based on `payment_intent`), **we insert:**  payment_intent, payment_intent, amount, studentId, classId, memberId, device, UTM metadata, and couponCode (if applied).
- On subsequent webhook calls (with the same `payment_intent`), we update the `status` and `receipt_url`.

### B. `stripe_checkout_customer`

On every webhook event, we update the `payment_intent` & `status` (Complete / Processing / Failed).

The unique identifier for stripe_checkout_customer is sessionId (Stripe Checkout Session ID), not payment_intent. All lookups use `db.stripe_checkout_customer.find_one({"sessionId": sessionId})`, and all updates use `db.stripe_checkout_customer.update_one({'sessionId': sessionId}, ...)`. The payment_intent is a field that gets updated on each webhook event (along with status), but sessionId is the primary key that uniquely identifies each checkout session record. This makes sense because a single checkout session can have multiple webhook events, so the sessionId remains constant while payment_intent and status can change over time.

<Note>
  TODO: I thought `payment_intent` was the unique identifier? If it's not, than what is the unique identifier for `stripe_checkout_customer`, that you get from Stripe?. **Added desc above**
</Note>

### C. Failure Handling

If payment fails, we delete the payment details and any upsell payments, and mark the checkout `status` as Failed in `stripe_checkout_customer`.

## Referral & Coupon Processing

**If a coupon is used**, Stripe passes it as **TODO: insert \<** a promotion code in the checkout session's discount breakdown. We retrieve it via getCouponCode(sessionId), which extracts the promotion code from total_details.breakdown.discounts.**\>**. We search to see if the coupon exists in **TODO: insert referral collection**\<referral_details\>. If a match is found, we mark the referral as Purchased and update the purchase date.

For any purchase, we check to see if the family (identified via their `familyId`) has a coupon in ****TODO: insert collection\<coupon_details\>**** . If it does not exist, we generate  **TODO: how?** \<a new referral coupon by calling  generate_coupon_name(firstName), which creates a unique code by: (1) taking the member's first name, (2) removing non-alphanumeric characters and converting to uppercase, (3) generating an MD5 hash of the name + "100", taking the first 5 characters, and (4) combining them as `BASENAME+5CHARHASH` (e.g., "JOHN12345")\>. a new referral coupon, create it in Stripe **TODO: are there any restrictions applied to this coupon?\<**The coupon includes restrictions: minimum purchase of \$100 (10,000 cents USD) and valid only for first-time transactions.**\>**, and store it in `coupon_details`.

<Note>
  TODO: I rewrote this part to add more detail. Please fill in the TODOs. We'll need to give more details about the referral section in a different page, but this should be sufficient for payment purposes.
</Note>

## Trial â†’ Paid Conversion

If the parent previously attended a trial class, the corresponding `trial_class_details`  is updated to `Purchased`. The lookup is performed via **TODO: explain**.\<if the user is exists in the trail class details based on parentId, then we are updating  the status to purchased\>

## Enrollment & Cleanup

- **Waitlist cleanup**: Searches for student in the `waitlist_details` via ****TODO: what key is used to search \<classId and studentId from stripeCheckout\>****. If found, then they are removed from the waitlist via deletion.
- **Upsell Programs** (if any): Inserted into `upsell_payment_details`
- **Topic Purchases** (if any): Inserted into topic payment collection

<Note>
  TODO: We'll likely need a seperate note to more thoroughly explain how upsells work. I'll figure out the right structure.
</Note>

## BDC Credit

If BDC credits were applied by the user, their credit balance is updated. \*\*TODO: how do we know if BDC credits were used; how is search done and in what collection. \*\*\<while processing the amount we are subtracting discount_amount, which we added in stripe_checkout_customer collections after payment, we are only subtracting from the member credit amount collection based on the discounted amount \>

## Emails Triggered

### Automated Emails

- **Admin Notification:** Sent on successful payment. Includes order & enrollment details
- **User Emails:** Automatically triggered receipt via Stripe. Same as the receipt_url stored in `payment_details`.